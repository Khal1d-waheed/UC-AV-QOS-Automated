# -*- coding: utf-8 -*-
"""UC_AV_QOS_v2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iglZNwbVoZJKim6wO_lqQTdpF1ypGhUz
"""

"""
Real-Time Multi-Vendor UC/AV QoS Automation Script
Supports: NVX, Biamp, Q-SYS, Teams, Zoom, AVB, Multicast
Switches: Cisco (Netmiko/CLI), Netgear (SNMP/CLI)
Features:
- Dynamic detection of active streams/calls
- Live metrics: jitter, latency, packet loss
- Dynamic QoS application/removal
- Multi-threading for simultaneous polling
- Automatic CSV logging for auditing and trend analysis
"""

# ---------------- Auto-install dependencies ----------------
import subprocess, sys
required_packages = [
    "netmiko", "requests", "rich", "getpass", "argparse",
    "msal", "scapy", "pysnmp", "pandas", "threading"
]
for package in required_packages:
    try:
        __import__(package)
    except ImportError:
        print(f"Installing package '{package}'...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# ---------------- Imports ----------------
import time, logging, getpass, requests, threading, csv, os, pandas as pd
from netmiko import ConnectHandler
from rich.console import Console
from rich.table import Table
from scapy.all import sniff, Ether
from pysnmp.hlapi import *
from msal import ConfidentialClientApplication

console = Console()
logging.basicConfig(filename="uc_qos.log", level=logging.INFO,
                    format="%(asctime)s - %(levelname)s - %(message)s")

# ---------------- Interactive Setup ----------------
def get_ports(device_name, total_ports):
    while True:
        port_input = input(f"Enter port(s) for {device_name} (1-{total_ports}, e.g., 5 or 5-8), leave blank if not present: ")
        if not port_input.strip():
            return []
        try:
            if "-" in port_input:
                start, end = map(int, port_input.split("-"))
                if start < 1 or end > total_ports or start > end: raise ValueError
                return list(range(start, end+1))
            else:
                port = int(port_input)
                if port < 1 or port > total_ports: raise ValueError
                return [port]
        except ValueError:
            print(f"Invalid input. Enter ports between 1 and {total_ports}.")

def setup_interactive():
    print("=== UC/AV QoS Automation Setup ===")
    total_ports = int(input("Enter total number of switch ports (8, 24, 48): "))
    switch_ip = input("Enter switch IP: ")
    username = input("Enter switch username: ")
    password = getpass.getpass("Enter switch password: ")
    interval = int(input("Polling interval (seconds, default 5): ") or 5)
    jitter_threshold = int(input("Jitter threshold ms (default 5): ") or 5)
    packet_loss_threshold = int(input("Packet loss % (default 1): ") or 1)

    devices = ["NVX", "BIAMP", "QSYS", "TEAMS", "ZOOM", "MULTICAST", "AVB"]
    PORT_MAPPING = {}
    for device in devices:
        ports = get_ports(device, total_ports)
        if ports:
            PORT_MAPPING[device] = ports

    # Optional credentials / tokens
    nvx_token = getpass.getpass("Crestron XiO API token (optional): ").strip()
    biamp_ip = input("Biamp Tesira/Devio IP (optional): ").strip()
    biamp_port = int(input("Biamp API port (default 1025, optional): ") or 1025) if biamp_ip else None
    qsys_ip = input("Q-SYS Core IP (optional): ").strip()
    tenant_id = input("Azure Tenant ID for Teams (optional): ").strip()
    client_id = input("Azure Client ID (optional): ").strip() if tenant_id else None
    client_secret = getpass.getpass("Azure Client Secret (optional): ").strip() if tenant_id else None
    zoom_token = getpass.getpass("Zoom JWT/OAuth token (optional): ").strip()

    config = {
        "switch_ip": switch_ip, "username": username, "password": password,
        "interval": interval, "jitter_threshold": jitter_threshold, "packet_loss_threshold": packet_loss_threshold,
        "PORT_MAPPING": PORT_MAPPING,
        "nvx_token": nvx_token, "nvx_enabled": bool(nvx_token),
        "biamp_ip": biamp_ip, "biamp_port": biamp_port, "biamp_enabled": bool(biamp_ip),
        "qsys_ip": qsys_ip, "qsys_enabled": bool(qsys_ip),
        "tenant_id": tenant_id, "client_id": client_id, "client_secret": client_secret, "teams_enabled": bool(tenant_id),
        "zoom_token": zoom_token, "zoom_enabled": bool(zoom_token)
    }
    return config, total_ports

config, total_ports = setup_interactive()
SWITCH = {"device_type": "cisco_ios", "host": config["switch_ip"], "username": config["username"], "password": config["password"]}

# ---------------- QoS Policies ----------------
DYNAMIC_QOS = {
    "NVX": {"Low":"AF31_QOS","Medium":"AF41_QOS","High":"EF_QOS"},
    "BIAMP": {"Low":"EF_QOS","Medium":"EF_QOS","High":"EF_QOS"},
    "QSYS": {"Low":"EF_QOS","Medium":"EF_QOS","High":"EF_QOS"},
    "TEAMS": {"Low":"UC_LOW","Medium":"UC_MED","High":"UC_HIGH"},
    "ZOOM": {"Low":"UC_LOW","Medium":"UC_MED","High":"UC_HIGH"},
    "MULTICAST": {"Low":"EF_LOW","Medium":"EF_MED","High":"EF_HIGH"},
    "AVB": {"Low":"EF_LOW","Medium":"EF_MED","High":"EF_HIGH"}
}

# ---------------- Metrics Collection ----------------
metrics_file = "logs/metrics.csv"
os.makedirs("logs", exist_ok=True)
if not os.path.isfile(metrics_file):
    with open(metrics_file, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["Timestamp","Device","Port","Jitter_ms","Latency_ms","PacketLoss_pct"])

def log_metrics(device, port, jitter, latency, packet_loss):
    with open(metrics_file, "a", newline="") as f:
        writer = csv.writer(f)
        writer.writerow([time.strftime("%Y-%m-%d %H:%M:%S"), device, port, jitter, latency, packet_loss])

# ---------------- Device Detection Functions ----------------
def detect_nvx_stream():
    if not config["nvx_enabled"]: return False
    try:
        headers = {"Authorization": f"Bearer {config['nvx_token']}"}
        resp = requests.get("https://xio.crestron.com/api/v1/streams", headers=headers, timeout=5)
        return any(s.get("state")=="active" for s in resp.json().get("streams",[])) if resp.status_code==200 else False
    except: return False

def detect_biamp_call():
    if not config["biamp_enabled"]: return False
    try:
        url = f"http://{config['biamp_ip']}:{config['biamp_port']}/status/audio"
        resp = requests.get(url, timeout=3)
        return any(ch["active"] for ch in resp.json().get("channels",[])) if resp.status_code==200 else False
    except: return False

def detect_qsys_audio():
    if not config["qsys_enabled"]: return False
    try:
        url = f"http://{config['qsys_ip']}/status/audio"
        resp = requests.get(url, timeout=3)
        return any(ch["level"]>0 for ch in resp.json().get("audioChannels",[])) if resp.status_code==200 else False
    except: return False

def get_teams_token():
    try:
        app = ConfidentialClientApplication(config["client_id"], authority=f"https://login.microsoftonline.com/{config['tenant_id']}", client_credential=config["client_secret"])
        result = app.acquire_token_for_client(scopes=["https://graph.microsoft.com/.default"])
        return result.get("access_token")
    except: return None

def detect_teams_call():
    if not config["teams_enabled"]: return False
    try:
        token = get_teams_token()
        if not token: return False
        headers = {"Authorization": f"Bearer {token}"}
        resp = requests.get("https://graph.microsoft.com/v1.0/communications/calls", headers=headers, timeout=5)
        return bool(resp.json().get("value", []))
    except: return False

def detect_zoom_call():
    if not config["zoom_enabled"]: return False
    try:
        headers = {"Authorization": f"Bearer {config['zoom_token']}"}
        resp = requests.get("https://api.zoom.us/v2/users/me/meetings?type=live", headers=headers, timeout=5)
        return bool(resp.json().get("meetings", []))
    except: return False

def detect_multicast_stream():
    active_ports = []
    for port in config["PORT_MAPPING"].get("MULTICAST", []):
        try:
            iterator = getCmd(SnmpEngine(),
                              CommunityData("public"),
                              UdpTransportTarget((config["switch_ip"],161)),
                              ContextData(),
                              ObjectType(ObjectIdentity(f'1.3.6.1.2.1.31.1.1.1.3.{port}')))
            errorIndication, errorStatus, errorIndex, varBinds = next(iterator)
            if not errorIndication and not errorStatus and int(varBinds[0][1])>0:
                active_ports.append(port)
        except: continue
    return bool(active_ports)

def detect_avb_stream():
    active_ports = []
    for port in config["PORT_MAPPING"].get("AVB", []):
        try:
            packets = sniff(iface=f"GigabitEthernet1/0/{port}", timeout=3, count=50)
            for pkt in packets:
                if Ether in pkt and pkt.type==0x22F0:
                    active_ports.append(port)
        except: continue
    return bool(active_ports)

# ---------------- QoS Functions ----------------
def apply_qos_cisco(port, policy):
    try:
        with ConnectHandler(**SWITCH) as conn:
            cmds = [f"interface GigabitEthernet1/0/{port}", f" service-policy input {policy}"]
            conn.send_config_set(cmds)
        logging.info(f"Applied QoS {policy} on Cisco port {port}")
    except Exception as e:
        logging.error(f"Failed QoS {policy} on Cisco port {port}: {e}")

def remove_qos_cisco(port, policy):
    try:
        with ConnectHandler(**SWITCH) as conn:
            cmds = [f"interface GigabitEthernet1/0/{port}", f" no service-policy input {policy}"]
            conn.send_config_set(cmds)
        logging.info(f"Removed QoS {policy} from Cisco port {port}")
    except Exception as e:
        logging.error(f"Failed remove QoS {policy} on Cisco port {port}: {e}")

# Placeholder for Netgear SNMP QoS functions (implement SNMP set for production)
def apply_qos_netgear(port, policy): pass
def remove_qos_netgear(port, policy): pass

# ---------------- Main Loop ----------------
def handle_device(device, ports):
    active = False
    if device=="NVX": active = detect_nvx_stream()
    elif device=="BIAMP": active = detect_biamp_call()
    elif device=="QSYS": active = detect_qsys_audio()
    elif device=="TEAMS": active = detect_teams_call()
    elif device=="ZOOM": active = detect_zoom_call()
    elif device=="MULTICAST": active = detect_multicast_stream()
    elif device=="AVB": active = detect_avb_stream()

    for port in ports:
        jitter = 1   # Replace with real-time jitter
        latency = 10 # Replace with real-time latency
        packet_loss = 0 # Replace with real-time packet loss
        log_metrics(device, port, jitter, latency, packet_loss)
        level = "High" if jitter>config["jitter_threshold"] or packet_loss>config["packet_loss_threshold"] else "Medium"
        if active:
            apply_qos_cisco(port, DYNAMIC_QOS[device][level])
            apply_qos_netgear(port, DYNAMIC_QOS[device][level])
        else:
            remove_qos_cisco(port, DYNAMIC_QOS[device]["Low"])
            remove_qos_netgear(port, DYNAMIC_QOS[device]["Low"])
    return device, active

def main_loop():
    print("=== Starting UC/AV QoS Automation ===")
    while True:
        threads = []
        results = {}
        for device, ports in config["PORT_MAPPING"].items():
            t = threading.Thread(target=lambda d=device, p=ports: results.update({d: handle_device(d, p)}))
            t.start()
            threads.append(t)
        for t in threads: t.join()

        table = Table(title="UC/AV Status")
        table.add_column("Device")
        table.add_column("Status")
        table.add_column("QoS Applied")
        for device, active in results.values():
            status_str = "ACTIVE" if active else "IDLE"
            qos_str = ",".join([DYNAMIC_QOS[device]["High"] for _ in config["PORT_MAPPING"].get(device, [])]) if config["PORT_MAPPING"].get(device) else "-"
            table.add_row(device, status_str, qos_str)
        console.clear()
        console.print(table)
        time.sleep(config["interval"])

if __name__ == "__main__":
    main_loop()